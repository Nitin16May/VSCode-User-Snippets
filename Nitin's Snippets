{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"basic": {
		"prefix": "basic",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "#define int long long",
		  "#define uint unsigned long long",
		  "#define float long double",
		  "#define double long double",
		  "#define endl '\\n'",
		  "#define yes cout<<\"YES\\n\"",
		  "#define no cout<<\"NO\\n\"",
		  "#define f(i,a,b) for(int i = a; i <= b; i++)",
		  "#define fr(i,a,b) for(int i = a; i >= b; i--)",
		  "#define all(x) x.begin(),x.end()",
		  "#define sz(x) ((int)(x).size())",
		  "#define vec vector<int>",
		  "#define dvec vector<vector<int>>",
		  "//////*************Nitin1605***************//////",
		  "",
		  "int32_t main()",
		  "{",
		  "    ios_base::sync_with_stdio(false);cin.tie(0),cout.tie(0);",
		  "    cout << fixed << setprecision(0);",
		  "    // #ifndef ONLINE_JUDGE",
		  "    // freopen(\"input.txt\", \"r\", stdin);",
		  "    // freopen(\"output.txt\", \"w\", stdout);",
		  "    // #endif",
		  "    int TESTCASES=1,n;",
		  "    cin>>TESTCASES;",
		  "    f(test,1,TESTCASES)",
		  "    {",
		  "        cin >> n;",
		  "    }",
		  "}"
		],
		"description": "basic"
	  }
	,"help": {
		"prefix": "help",
		"body": [
		  "//Number Theory",
		  "// ",
		  "//isprime checks if n is prime",
		  "//primefactorsofn gives list of prime factors of n",
		  "//factorisation gives list and its power of prime factors",
		  "//factorsofn gives all factors of n",
		  "//PrimeGen generates prime from 1 to limit",
		  "//",
		  "//gcd use __gcd(a,b) instead samme thing",
		  "//lcm LCM of 2 numbers",
		  "//",
		  "//isPowerOfTwo return true if it is a power of two",
		  "//highestPowerOf2multiple  returns 2 for 14 ...32 for 96",
		  "//nextPowerOf2 returns power of 2 greater than or equal to the number",
		  "//power power with mod in log n time",
		  "//",
		  "//nCr",
		  "//ncrwithmod",
		  "//precomputencr ",
		  "",
		  "//Skeleton Codes",
		  "//oset ordered set",
		  "//modint custom datatype for safe modding",
		  "//dijkstra shortest paths to all n nodes",
		  "//LargestSumSubarray kadane's algorithm with positions too",
		  "",
		  "//bitmasking",
		  "//string DecToBin(int n);//10^9-->32 10^19--->64",
		  "//int BinToDec(string s);",
		  "//string addBitStrings(string str1, string str2);//adds two bit strings",
		  "//XOR0ton XOR of 0 1 2 3 4 ..... n",
		  "//numberOfOnesBitset number Of Ones Bitset representation of n",
		  "",
		  "//Binary Search",
		  "//FirstTrue",
		  "//LastTrue",
		  "",
		  "//Geometry",
		  "//int RectangleArea(int x1,int y1,int x2,int y2);",
		  "//int TwoRectangleOverlappingArea(int ax1,int ay1,int ax2,int ay2,int bx1,int by1,int bx2,int by2);",
		  "//int ThreeRectangleOverlappingArea(int ax1,int ay1,int ax2,int ay2,int bx1,int by1,int bx2,int by2,int cx1,int cy1,int cx2,int cy2);",
		  ""
		],
		"description": "help"
	  }
	,"RectangleArea": {
		"prefix": "RectangleArea",
		"body": [
		  "int RectangleArea(int x1,int y1,int x2,int y2)",
		  "{",
		  "    int area=(x2-x1)*abs(y2-y1);",
		  "    return area;",
		  "}"
		],
		"description": "RectangleArea"
	  }

	,"TwoRectangleOverlappingArea": {
		"prefix": "TwoRectangleOverlappingArea",
		"body": [
		  "int TwoRectangleOverlappingArea(int ax1,int ay1,int ax2,int ay2,int bx1,int by1,int bx2,int by2)//ax2>ax1 and so on",
		  "{",
		  "    int xOverlap = max((int)0,(min(ax2,bx2)-max(ax1,bx1)));",
		  "    int yOverlap = max((int)0,(min(ay2,by2)-max(ay1,by1)));",
		  "    return xOverlap * yOverlap;",
		  "}"
		],
		"description": "TwoRectangleOverlappingArea"
	  }
	  ,"ThreeRectangleOverlappingArea": {
		"prefix": "ThreeRectangleOverlappingArea",
		"body": [
		  "int ThreeRectangleOverlappingArea(int ax1,int ay1,int ax2,int ay2,int bx1,int by1,int bx2,int by2,int cx1,int cy1,int cx2,int cy2)//ax2>ax1 and so on",
		  "{",
		  "    int xOverlap = max((int)0,(min(ax2,bx2)-max(ax1,bx1)));",
		  "    int yOverlap = max((int)0,(min(ay2,by2)-max(ay1,by1)));",
		  "    if(xOverlap * yOverlap == 0)",
		  "    return 0;",
		  "    else",
		  "    return TwoRectangleOverlappingArea(max(ax1,bx1),max(ay1,by1),min(ax2,bx2),min(ay2,by2),cx1,cy1,cx2,cy2);",
		  "}"
		],
		"description": "ThreeRectangleOverlappingArea"
	  }
	  ,"DecToBin": {
		"prefix": "DecToBin",
		"body": [
		  "string DecToBin(int n)",
		  "{return bitset<32>(n).to_string();}"
		],
		"description": "DecToBin"
	  }
	  ,"BinToDec": {
		"prefix": "BinToDec",
		"body": [
		  "int BinToDec(string n)",
		  "{",
		  "    int l=0,r=1;",
		  "    fr(i,n.size()-1,0)",
		  "    {",
		  "        if(n[i]=='1')",
		  "        l=l+r;",
		  "        r=r*2;",
		  "    }",
		  "    return l;",
		  "}"
		],
		"description": "BinToDec"
	  }
	  ,"FirstTrue": {
		"prefix": "FirstTrue",
		"body": [
		  "int FirstTrue(int lo,int hi,function<bool(int)> func) ",
		  "{",
		  "    hi++;",
		  "    while (lo < hi) ",
		  "    {",
		  "        int mid=lo+(hi-lo)/2;",
		  "        if (func(mid))hi=mid;",
		  "        else lo=mid+1;",
		  "    }",
		  "    return lo;",
		  "}"
		],
		"description": "FirstTrue"
	  }
	  ,"LastTrue": {
		"prefix": "LastTrue",
		"body": [
		  "int LastTrue(int lo,int hi,function<bool(int)> func) ",
		  "{",
		  "    lo--;",
		  "    while(lo<hi) ",
		  "    {",
		  "        int mid=lo+(hi-lo+1)/2;",
		  "        if (func(mid))lo=mid;",
		  "        else hi=mid-1;",
		  "    }",
		  "    return lo;",
		  "}"
		],
		"description": "LastTrue"
	  }
	  ,"PrimeGen": {
		"prefix": "PrimeGen",
		"body": [
		  "vector<int> primes;",
		  "void PrimeGen(int limit)",
		  "{",
		  "    bool sieve[limit];",
		  "    for (int i = 0; i < limit; i++)sieve[i] = false;",
		  "    if (limit > 2)sieve[2] = true;",
		  "    if (limit > 3)sieve[3] = true;",
		  "    for (int x = 1; x * x <= limit; x++) ",
		  "    {",
		  "        for (int y = 1; y * y <= limit; y++) ",
		  "        {",
		  "            int n = (4 * x * x) + (y * y);",
		  "            if (n <= limit && (n % 12 == 1 || n % 12 == 5))sieve[n] ^= true;",
		  "            n = (3 * x * x) + (y * y);",
		  "            if (n <= limit && n % 12 == 7)sieve[n] ^= true;",
		  "            n = (3 * x * x) - (y * y);",
		  "            if (x > y && n <= limit && n % 12 == 11)sieve[n] ^= true;",
		  "        }",
		  "    }",
		  "    for (int r = 5; r * r <= limit; r++) ",
		  "    {",
		  "        if (sieve[r])",
		  "        for (int i = r * r; i <= limit; i += r * r)sieve[i] = false;",
		  "    }",
		  "    for (int a = 1; a <= limit; a++)",
		  "    if (sieve[a])primes.push_back(a);",
		  "}"
		],
		"description": "PrimeGen"
	  }
	  ,"Kadane Largest Sum of Subarray": {
		"prefix": "LargestSumSubarray",
		"body": [
		  "void LargestSumSubarray()",
		  "{",
		  "    //change arr",
		  "    int max_so_far=LLONG_MIN,max_ending_here=0,start=0,end=0,maybe_start=0;",
		  "    for (int j=0;j<n;j++)",
		  "    {",
		  "        max_ending_here=max_ending_here+arr[j];",
		  "        if(max_ending_here<arr[j]){max_ending_here=arr[j];maybe_start=j+1;}",
		  "        if(max_so_far<max_ending_here){max_so_far=max_ending_here;start=maybe_start;end=j+1;}",
		  "    }",
		  "    //max_so_far-->largest sum",
		  "    //start------->starting index",
		  "    //end--------->ending index",
		  "}",
		  ""
		],
		"description": "Kadane Largest Sum of Subarray"
	  }
	  ,"GCD": {
		"prefix": "gcd",
		"body": [
		  "int gcd(int a,int b)",
		  "{return __gcd(a,b);}"
		],
		"description": "GCD"
	  }
	  ,"LCM": {
		"prefix": "lcm",
		"body": [
		  "int lcm(int a,int b)",
		  "{int c=(a/__gcd(a,b))*b;return c;}"
		],
		"description": "LCM"
	  }
	  ,"isPowerOfTwo": {
		"prefix": "isPowerOfTwo",
		"body": [
		  "bool isPowerOfTwo(int x)",
		  "{return x && (!(x&(x-1)));}"
		],
		"description": "isPowerOfTwo"
	  }
	  ,"addBitStrings": {
		"prefix": "addBitStrings",
		"body": [
		  "string addBitStrings(string str1, string str2)",
		  "{",
		  "    string ans = \"\";",
		  "    int i=str1.size()-1,j=str2.size()-1,carry=0;",
		  "    while(i>=0 || j>=0 || carry) ",
		  "    {",
		  "        carry+=((i>=0)?(str1[i--]-'0'):(0));",
		  "        carry+=((j>=0)?(str2[j--]-'0'):(0));",
		  "        ans=char('0'+(carry%2))+ans;",
		  "        carry=carry/2;",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "addBitStrings"
	  }
	  ,"highestPowerOf2": {
		"prefix": "highestPowerOf2multiple",
		"body": [
		  "int highestPowerOf2multiple(int n)",
		  "{return n & (~(n - 1));}"
		],
		"description": "highestPowerOf2multiple"
	  }
	  ,"nextPowerOf2": {
		"prefix": "nextPowerOf2",
		"body": [
		  "int nextPowerOf2(int N)",
		  "{",
		  "    if (!(N & (N - 1)))return N;",
		  "    return 0x8000000000000000 >> (__builtin_clzll(N) - 1);",
		  "}"
		],
		"description": "nextPowerOf2"
	  }
	  ,"nCr": {
		"prefix": "nCr",
		"body": [
		  "int nCr(int n,int r)",
		  "{",
		  "    int p = 1, k = 1;",
		  "    if(n-r<r)r=n-r;",
		  "    if (r != 0) ",
		  "    {",
		  "        while (r) ",
		  "        {",
		  "            p*=n;k*=r;",
		  "            int m=__gcd(p,k);p/=m;k/=m;",
		  "            n--;r--;",
		  "        }",
		  "    }",
		  "    else p = 1;",
		  "    return p;",
		  "}"
		],
		"description": "nCr"
	  }
	  ,"ordered set": {
		"prefix": "oset",
		"body": [
		  "#include <ext/pb_ds/assoc_container.hpp>",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "using namespace __gnu_pbds;",
		  "template<class T> using oset =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;",
		  ""
		],
		"description": "ordered set"
	  }
	  ,"modded power": {
		"prefix": "power",
		"body": [
		  "int power(int x, int y)",
		  "{",
		  "    int result=1;",
		  "    while(y>0) ",
		  "    {",
		  "      if(y&1==1)result=(result*x)%1000000007;",
		  "      x=(x*x)%1000000007;",
		  "      y=y>>1;",
		  "    }",
		  "    return result;",
		  "}"
		],
		"description": "modded power"
	  }
	  ,"isprime": {
		"prefix": "isprime",
		"body": [
		  "bool isPrime(int num) ",
		  "{",
		  "    if(num <= 1)return false;",
		  "    if (num <= 3)return true; ",
		  "    int range = sqrt(num);",
		  "    if (num%2==0 || num%3==0)return false; ",
		  "    for (int i = 5; i <= range; i += 6) ",
		  "    if (num % i == 0 || num % (i + 2) == 0)return false;",
		  "    return true;",
		  "}"
		],
		"description": "isprime"
	  }
	  ,"prime factors of n": {
		"prefix": "primefactorsofn",
		"body": [
		  "void primeFactors(vector<int> s,int n)",
		  "{",
		  "    if(n%2==0)s.pb(2);",
		  "    while (n%2==0)n=n/2;",
		  "    for(int i=3;i<=sqrt(n);i+=2)",
		  "    {",
		  "        if(n%i==0) s.pb(i);",
		  "        while (n%i==0)n = n/i;",
		  "    }",
		  "    if(n>2)s.pb(n);",
		  "}"
		],
		"description": "prime factors of n"
	  }
	  ,"Modint": {
		"prefix": "modint",
		"body": [
		  "template <int mod> struct ModInt",
		  "{",
		  "    int32_t x;",
		  "",
		  "    ModInt() : x(0)",
		  "    {",
		  "    }",
		  "",
		  "    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod)",
		  "    {",
		  "    }",
		  "",
		  "    ModInt &operator+=(const ModInt &p)",
		  "    {",
		  "        if ((x += p.x) >= mod)",
		  "            x -= mod;",
		  "        return *this;",
		  "    }",
		  "",
		  "    ModInt &operator-=(const ModInt &p)",
		  "    {",
		  "        if ((x += mod - p.x) >= mod)",
		  "            x -= mod;",
		  "        return *this;",
		  "    }",
		  "",
		  "    ModInt &operator*=(const ModInt &p)",
		  "    {",
		  "        x = (int)(1LL * x * p.x % mod);",
		  "        return *this;",
		  "    }",
		  "",
		  "    ModInt &operator/=(const ModInt &p)",
		  "    {",
		  "        *this *= p.inverse();",
		  "        return *this;",
		  "    }",
		  "",
		  "    ModInt operator-() const",
		  "    {",
		  "        return ModInt(-x);",
		  "    }",
		  "",
		  "    ModInt operator+(const ModInt &p) const",
		  "    {",
		  "        return ModInt(*this) += p;",
		  "    }",
		  "",
		  "    ModInt operator-(const ModInt &p) const",
		  "    {",
		  "        return ModInt(*this) -= p;",
		  "    }",
		  "",
		  "    ModInt operator*(const ModInt &p) const",
		  "    {",
		  "        return ModInt(*this) *= p;",
		  "    }",
		  "",
		  "    ModInt operator/(const ModInt &p) const",
		  "    {",
		  "        return ModInt(*this) /= p;",
		  "    }",
		  "",
		  "    bool operator==(const ModInt &p) const",
		  "    {",
		  "        return x == p.x;",
		  "    }",
		  "",
		  "    bool operator!=(const ModInt &p) const",
		  "    {",
		  "        return x != p.x;",
		  "    }",
		  "",
		  "    ModInt inverse() const",
		  "    {",
		  "        int a = x, b = mod, u = 1, v = 0, t;",
		  "        while (b > 0)",
		  "        {",
		  "            t = a / b;",
		  "            swap(a -= t * b, b);",
		  "            swap(u -= t * v, v);",
		  "        }",
		  "        return ModInt(u);",
		  "    }",
		  "",
		  "    ModInt pow(int64_t n) const",
		  "    {",
		  "        ModInt ret(1), mul(x);",
		  "        while (n > 0)",
		  "        {",
		  "            if (n & 1)",
		  "                ret *= mul;",
		  "            mul *= mul;",
		  "            n >>= 1;",
		  "        }",
		  "        return ret;",
		  "    }",
		  "",
		  "    friend ostream &operator<<(ostream &os, const ModInt &p)",
		  "    {",
		  "        return os << p.x;",
		  "    }",
		  "",
		  "    friend istream &operator>>(istream &is, ModInt &a)",
		  "    {",
		  "        int64_t t;",
		  "        is >> t;",
		  "        a = ModInt<mod>(t);",
		  "        return (is);",
		  "    }",
		  "",
		  "    int get() const",
		  "    {",
		  "        return x;",
		  "    }",
		  "",
		  "    static constexpr int get_mod()",
		  "    {",
		  "        return mod;",
		  "    }",
		  "};"
		],
		"description": "Modint"
	  }
	  ,"Dijkstra": {
		"prefix": "dijkstra",
		"body": [
		  "vector<vector<pair<int,int>>> graph(100001);// v w",
		  "vector<int> dist(100001,LLONG_MAX);",
		  "void the_D_algo()",
		  "{",
		  "    dist[1] = 0;",
		  "    const auto comp = [](auto &a, auto &b){return a.second > b.second;};",
		  "    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> q(comp);",
		  "    q.push({1,0});",
		  "    while (!q.empty())",
		  "    {",
		  "        auto i = q.top();",
		  "        q.pop();",
		  "        if (i.second > dist[i.first])continue;",
		  "        for (auto j : graph[i.first])",
		  "        {",
		  "            if (dist[j.first] > dist[i.first] + j.second)",
		  "            {",
		  "                dist[j.first] = dist[i.first] + j.second;",
		  "                q.push({j.first, dist[j.first]});",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Dijkstra"
	  }
	  ,"PrecomputeNCR": {
		"prefix": "precomputencr",
		"body": [
		  "const int MAXN = 1e6;",
		  "const int MOD = 1e9 + 7;",
		  "int fac[MAXN + 1];",
		  "int inv[MAXN + 1];",
		  "int exp(int x, int y, int p) ",
		  "{",
		  "    int res = 1; x %= p;",
		  "    while (y) {",
		  "        if (y & 1) {",
		  "        res *= x; res %= p;",
		  "    }",
		  "    x *= x;",
		  "    x %= p;",
		  "    y >>= 1;",
		  "}",
		  "return res;",
		  "}",
		  "void factorial() {",
		  "    fac[0] = 1;",
		  "    for (int i = 1; i <= MAXN; i++) {",
		  "    fac[i] = fac[i - 1] * i % MOD;",
		  "}",
		  "}",
		  "void inverses() {",
		  "    inv[0] = 1;",
		  "    for (int i = 1; i <= MAXN; i++) {",
		  "    inv[i] = exp(fac[i], MOD - 2, MOD);",
		  "    }",
		  "}",
		  "int choose(int n, int r) {",
		  "    return fac[n] * inv[r] % MOD * inv[n - r] % MOD;",
		  "}",
		  "//run factorial and inverse in main to precompute in O(nlogMOD) then O(1)queries"
		],
		"description": "PrecomputeNCR"
	  }
	  ,"ncrwithmod": {
		"prefix": "ncrmod",
		"body": [
		  "int nCr(int n, int k, int p) {",
		  "    // dp[i][j] stores iCj",
		  "    vector<vector<int>> dp(n + 1, vector<int> (k + 1, 0));",
		  "    // base cases described above",
		  "    for (int i = 0; i <= n; i++) {",
		  "    /*",
		  "     * i choose 0 is always 1 since there is exactly one way ",
		  "     * to choose 0 elements from a set of i elements ",
		  "     * (don't choose anything)",
		  "     */",
		  "    dp[i][0] = 1;",
		  "    /*",
		  "     * i choose i is always 1 since there is exactly one way ",
		  "     * to choose i elements from a set of i elements",
		  "     * (choose every element in the set)",
		  "     */",
		  "    if (i <= k) {",
		  "    dp[i][i] = 1; ",
		  "    }",
		  "    }",
		  "    for (int i = 0; i <= n; i++) {",
		  "    for (int j = 1; j <= min(i, k); j++) {",
		  "    if (i != j) {  // skips over the base cases",
		  "    // uses the recurrence relation above",
		  "    dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % p;",
		  "    }",
		  "    }",
		  "    }",
		  "    return dp[n][k];  // returns nCk modulo p",
		  "}"
		],
		"description": "ncrwithmod"
	  }
	  ,"factorisation": {
		"prefix": "factorisation",
		"body": [
		  "void Factorisation(int n,vector<pair<int,int>> &s)",
		  "{",
		  "    if(n%2==0)s.pb({2,0});",
		  "    while(n%2==0){n=n/2;s[s.size()-1].second++;}",
		  "    for(int i=3;i<=sqrt(n);i+=2)",
		  "    {",
		  "        if(n%i==0)s.pb({i,0});",
		  "        while(n%i==0){n=n/i;s[s.size()-1].second++;}",
		  "    }",
		  "    if(n>2)s.pb({n,1});",
		  "}"
		],
		"description": "factorisation"
	  }
	  ,"XOR0ton": {
		"prefix": "XOR0ton",
		"body": [
		  "int computeXOR(int n)//XOR of 0 1 2 3 4 ..... n",
		  "{",
		  "    if(n==0)return 0;",
		  "    if (n % 4 == 0)return n;",
		  "    if (n % 4 == 1)return 1;",
		  "    if (n % 4 == 2)return n + 1;",
		  "    return 0;",
		  "}"
		],
		"description": "XOR0ton"
	  }
	  ,"numberOfOnesBitset": {
		"prefix": "numberOfOnesBitset",
		"body": [
		  "int numberOfOnesBitset(int n)",
		  "{",
		  "    cout << __builtin_popcount(n);",
		  "}"
		],
		"description": "numberOfOnesBitset"
	  }
	  ,"factorsofn": {
		"prefix": "factorsofn",
		"body": [
		  "vector<int> factors;",
		  "void factorsofn(int n)",
		  "{",
		  "    for (int i=1; i<=sqrt(n); i++)",
		  "    {",
		  "        if (n%i == 0)",
		  "        {",
		  "            if (n/i == i)factors.push_back(i);",
		  "            else{factors.push_back(i);factors.push_back(n/i);}",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "factorsofn"
	  }
	  ,"lazysegtree": {
		"prefix": "lazysegtree",
		"body": [
		  "template <typename treetype>class segtree",
		  "{",
		  "    public:",
		  "    treetype operation(treetype operand1,treetype operand2)",
		  "    {",
		  "        return min(operand1,operand2);",
		  "    }",
		  "    void merge(int pos)",
		  "    {",
		  "        if(pos<=N-1)nodes[pos]=operation(nodes[2*pos],nodes[2*pos+1]);",
		  "    }",
		  "    void lazy_operation(int pos,int present_start,int present_end,treetype value)",
		  "    {",
		  "        pending[pos]+=value;",
		  "    }",
		  "    void activate(int pos)",
		  "    {",
		  "        if(pending[pos]==default_value_of_pending)return;",
		  "        nodes[pos]=nodes[pos]+pending[pos];",
		  "        if(pos<=N-1)",
		  "        {",
		  "            pending[pos*2]+=pending[pos];",
		  "            pending[pos*2+1]+=pending[pos];",
		  "        }",
		  "        pending[pos]=default_value_of_pending;",
		  "    }",
		  "    void input()",
		  "    {",
		  "        f(i,1,n)cin >> nodes[N+i-1];",
		  "        fr(i,N-1,1)merge(i);",
		  "    }",
		  "    vector<treetype> nodes,pending;",
		  "    int N,n;",
		  "    treetype default_value,default_value_of_pending;",
		  "    segtree(int si,treetype temp,treetype temp2)",
		  "    {",
		  "        n=si;N=n;",
		  "        if(N & (N - 1))N=0x8000000000000000 >> (__builtin_clzll(N) - 1);",
		  "        if(N==1)N=2;",
		  "        nodes.assign(N*2+5,temp);",
		  "        pending.assign(N*2+5,temp);",
		  "        default_value=temp;",
		  "        default_value_of_pending=temp2;",
		  "    };",
		  "    treetype query(int start,int end)",
		  "    {",
		  "        return pvquery(1,start,end,1,N);",
		  "    }",
		  "    treetype query(int pos)",
		  "    {",
		  "        return pvquery(1,pos,pos,1,N);",
		  "    }",
		  "    void update(int destination,treetype value)",
		  "    {",
		  "        pointupdate(1,1,N,destination,value);",
		  "    }",
		  "    void update(int start,int end,treetype value)",
		  "    {",
		  "        rangeupdate(1,1,N,start,end,value);",
		  "    }",
		  "    void printtree()",
		  "    {",
		  "        int NextTwo=1,count=0;",
		  "        f(i,1,N+N-1)",
		  "        {",
		  "            cout << nodes[i] << \" \";",
		  "            count++;",
		  "            if(count==NextTwo)",
		  "            {",
		  "                cout << endl;",
		  "                NextTwo=NextTwo*2;count=0;",
		  "            }",
		  "        }",
		  "        cout << endl;",
		  "        NextTwo=1;count=0;",
		  "        f(i,1,N+N-1)",
		  "        {",
		  "            cout << pending[i] << \" \";",
		  "            count++;",
		  "            if(count==NextTwo)",
		  "            {",
		  "                cout << endl;",
		  "                NextTwo=NextTwo*2;count=0;",
		  "            }",
		  "        }",
		  "        cout << endl;",
		  "    }",
		  "    private:",
		  "    treetype pvquery(int pos,int start,int end,int present_start,int present_end)",
		  "    {",
		  "        activate(pos);",
		  "        if(present_end<=end && present_start>=start)return nodes[pos];",
		  "        if(present_end<start || present_start>end)return default_value;",
		  "        return operation(pvquery(pos*2,start,end,present_start,present_start+(present_end-present_start+1)/2-1),pvquery(pos*2+1,start,end,present_start+(present_end-present_start+1)/2,present_end));",
		  "    }",
		  "    treetype pointupdate(int pos,int present_start,int present_end,int destination,treetype value)",
		  "    {",
		  "        activate(pos);",
		  "        if(present_end<destination || present_start>destination)return nodes[pos];",
		  "        if(present_end==present_start)nodes[pos]=value;",
		  "        else",
		  "        {",
		  "            nodes[pos*2]=pointupdate(pos*2,present_start,present_start+(present_end-present_start+1)/2-1,destination,value);",
		  "            nodes[pos*2+1]=pointupdate(pos*2+1,present_start+(present_end-present_start+1)/2,present_end,destination,value);",
		  "            merge(pos);",
		  "        }",
		  "        return nodes[pos];",
		  "    }",
		  "    void rangeupdate(int pos,int present_start,int present_end,int start,int end,treetype value)",
		  "    {",
		  "        if(present_end<=end && present_start>=start)",
		  "        {",
		  "            lazy_operation(pos,present_start,present_end,value);",
		  "            return;",
		  "        }",
		  "        if(present_end<start || present_start>end)return;",
		  "        rangeupdate(pos*2,present_start,present_start+(present_end-present_start+1)/2-1,start,end,value);",
		  "        rangeupdate(pos*2+1,present_start+(present_end-present_start+1)/2,present_end,start,end,value);",
		  "    }",
		  "};"
		],
		"description": "lazysegtree"
	  }
	  ,"segtree": {
		"prefix": "segtree",
		"body": [
		  "template <typename treetype>class segtree",
		  "{",
		  "    public:",
		  "    treetype operation(treetype operand1,treetype operand2)",
		  "    {",
		  "        return min(operand1,operand2);",
		  "    }",
		  "    void merge(int pos)",
		  "    {",
		  "        if(pos<=N-1)nodes[pos]=operation(nodes[2*pos],nodes[2*pos+1]);",
		  "    }",
		  "    void input()",
		  "    {",
		  "        f(i,1,n)cin >> nodes[N+i-1];",
		  "        fr(i,N-1,1)merge(i);",
		  "    }",
		  "    vector<treetype> nodes;",
		  "    int N,n;",
		  "    treetype default_value;",
		  "    segtree(int si,treetype temp)",
		  "    {",
		  "        n=si;N=n;",
		  "        if(N & (N - 1))N=0x8000000000000000 >> (__builtin_clzll(N) - 1);",
		  "        if(N==1)N=2;",
		  "        nodes.assign(N*2+5,temp);",
		  "        default_value=temp;",
		  "    };",
		  "    treetype query(int start,int end)",
		  "    {",
		  "        return pvquery(1,start,end,1,N);",
		  "    }",
		  "    treetype query(int pos)",
		  "    {",
		  "        return pvquery(1,pos,pos,1,N);",
		  "    }",
		  "    void update(int destination,treetype value)",
		  "    {",
		  "        pointupdate(1,1,N,destination,value);",
		  "    }",
		  "    void printtree()",
		  "    {",
		  "        int NextTwo=1,count=0;",
		  "        f(i,1,N+N-1)",
		  "        {",
		  "            cout << nodes[i] << \" \";",
		  "            count++;",
		  "            if(count==NextTwo)",
		  "            {",
		  "                cout << endl;",
		  "                NextTwo=NextTwo*2;count=0;",
		  "            }",
		  "        }",
		  "        cout << endl;",
		  "    }",
		  "    private:",
		  "    treetype pvquery(int pos,int start,int end,int present_start,int present_end)",
		  "    {",
		  "        if(present_end<=end && present_start>=start)return nodes[pos];",
		  "        if(present_end<start || present_start>end)return default_value;",
		  "        return operation(pvquery(pos*2,start,end,present_start,present_start+(present_end-present_start+1)/2-1),pvquery(pos*2+1,start,end,present_start+(present_end-present_start+1)/2,present_end));",
		  "    }",
		  "    treetype pointupdate(int pos,int present_start,int present_end,int destination,treetype value)",
		  "    {",
		  "        if(present_end<destination || present_start>destination)return nodes[pos];",
		  "        if(present_end==present_start)nodes[pos]=value;",
		  "        else",
		  "        {",
		  "            nodes[pos*2]=pointupdate(pos*2,present_start,present_start+(present_end-present_start+1)/2-1,destination,value);",
		  "            nodes[pos*2+1]=pointupdate(pos*2+1,present_start+(present_end-present_start+1)/2,present_end,destination,value);",
		  "            merge(pos);",
		  "        }",
		  "        return nodes[pos];",
		  "    }",
		  "};"
		],
		"description": "segtree"
	  }
}
